import select
import logging
import sys
import pyorient
import os

import xmltodict
import datetime
import time

import timeout_decorator

from multiprocessing import Process, Queue
import xml.etree.ElementTree as ET

from topology import edges, nodes

logger = logging.getLogger("idrs")

lldosFolder = "./producer/lldos/"
cleanDBFromAlert = True

EVAL = True
if EVAL:
    listenTo = ['alert']
    name = 'lldosReader'


class Alert():

    def __init__(self, alertID):
        self.msgID = alertID
        self.source = None
        self.target = None
        self.classification = None
        self.dt = None

    def printAlert(self):
        return ("Message ID = " + self.msgID + " Source = " + self.source + " Target = " + self.target + " Classification = " + self.classification)

class PlugIn (Process):

    alertList = {}
    sourceIP = {}
    targetIP = {}
    classification = {}
    timeList = {}

    def __init__(self, dbs):
        Process.__init__(self)
        self.client = pyorient.OrientDB(dbs.server, dbs.port)
        self.session_id = self.client.connect(dbs.user, dbs.pwd)
        self.client.db_open(dbs.database, dbs.user, dbs.pwd)
        if EVAL:
            self.subscribe = q[listenTo[0] + '_' + name]

    def stop(self):
        logger.info( 'Stopped "{0}"'.format(self.__module__) )
        self.client.db_close()

    def createData(self):
        for ip in self.sourceIP.keys():
            ipNode = nodes.ip(ip, client = self.client)
            self.sourceIP[ip] = ipNode.rid
        for ip in self.targetIP.keys():
            ipNode = nodes.ip(ip, client = self.client)
            self.targetIP[ip] = ipNode.rid
        for classification in self.classification.keys():
            typeNode = nodes.attack(classification, client = self.client)
            self.classification[classification] = typeNode.rid

    def cleanDB(self):
        for i in range(10):
            try:
                self.client.command("delete vertex alert")
                self.client.command("delete vertex alertcontext")
                self.client.command("truncate class alert")
                self.client.command("truncate class alertcontext")
                break
            except:
                pass
    
    @timeout_decorator.timeout(1)
    def getValue(self):
        return self.subscribe.get()

    def createAlerts(self, fileName):

        start = time.time()

        for alert in self.alertList[fileName]:

            query = (
                "select EXPAND($inter2) "
                "LET $a = (select EXPAND(IN('alertContextHasTarget')) from ip where @RID = " + self.targetIP[alert.target] + "), "
                "$b = (select EXPAND(IN('alertContextHasSource')) from ip where @RID = " + self.sourceIP[alert.source] + "), "
                "$c = (select EXPAND(IN('alertContextIsOfType')) from attack where @RID = " + self.classification[alert.classification] + "), "
                "$inter1 = INTERSECT($a, $b), $inter2 = INTERSECT($inter1, $c)"
            )

            result = self.client.query(query,-1)

            contextName = str(alert.source) + "_" + str(alert.target) + "_" + str(alert.classification) 
            contextRID = "(select from alertcontext where name = '" + contextName + "')"
            alertRID = "(select from alert where name = '" + alert.msgID + "' and detectiontime = DATE('" + str(alert.dt) + " '))"

            if len(result) == 0:
            
                cmd = ("begin;"
                "let $a = create vertex alert set name = '" + alert.msgID + "', detectiontime = DATE('" + str(alert.dt) + "');"
                "let $b = create vertex alertcontext set name = '" + contextName + "', _solved = 'False' ;"
                "let $c = create edge alertContextIsOfType from " + contextRID + " to "  + self.classification[alert.classification] + " set name = 'alertContextIsOfType';"
                "let $d = create edge alertContextHasSource from " + contextRID + " to "  + self.sourceIP[alert.source] + " set name = 'alertContextHasSource';"
                "let $e = create edge alertContextHasTarget from " + contextRID + " to "  + self.targetIP[alert.target] + "set name = 'alertContextHasTarget';"
                "let $f = create edge alertToContext from " + alertRID + " to "  + contextRID + "set name = 'alertToContext';"
                "commit;")

            else:
                
                cmd = ("begin;" +
                "let $a = create vertex alert set name = '" + alert.msgID + "', detectiontime = DATE('" + str(alert.dt) + "');"
                "let $f = create edge alertToContext from " + alertRID + " to "  + result[0]._rid + "set name = 'alertToContext';"
                "commit;")
            
            
            for i in range (10):
                try:
                    self.client.batch(cmd)
                    break
                except:
                    pass

        while (True):
            try:
                changed = self.getValue()
            except:
                break

        end = time.time()

        duration = end - start

        self.timeList[fileName].append(start)
        self.timeList[fileName].append(end)
        self.timeList[fileName].append(duration)
        self.timeList[fileName].append(len(self.alertList[fileName]))

    def readLLDOSFile(self, fileName):

        tree = ET.parse(lldosFolder+fileName)      
        root = tree.getroot()

        for idmefMsg in root:
            for alert in idmefMsg:
                alertElem = Alert(alert.get('alertid'))
                alertElem.source = alert.findall(".//Source//address")[0].text
                alertElem.target = alert.findall(".//Target//address")[0].text
                try:
                    alertClass = alert.findall(".//Service//name")[0].text + alert.findall(".//Service//dport")[0].text
                except:
                    alertClass = alert.findall(".//Service//name")[0].text
                alertElem.classification = alertClass
                creation = alert.findall(".//Time//date")[0].text + " " + alert.findall(".//Time//time")[0].text
                formattedTime = time.strptime(creation, "%d/%m/%Y %H:%M:%S")
                dt = datetime.datetime.fromtimestamp(time.mktime(formattedTime))
                alertElem.dt = dt
                self.alertList[fileName].append(alertElem)
                self.sourceIP[alertElem.source] = True
                self.targetIP[alertElem.target] = True
                self.classification[alertElem.classification] = True

        for entry in self.alertList.keys():
            for elem in self.alertList[entry]:
                logger.debug("File : %s has Alert =  %s", entry, elem.printAlert())   

        logger.info("Source IPs found: %s", self.sourceIP.keys())
        logger.info("Target IPs found: %s", self.targetIP.keys())
        logger.info("Classifications found: %s", self.classification.keys())


    def run(self):

        logger.info( 'Start "{0}"'.format(self.__module__) )
    
        for fileName in os.listdir(lldosFolder):
            if fileName.endswith(".xml"):
                self.alertList[fileName] = []
                self.timeList[fileName] = []
                self.readLLDOSFile(fileName)

        print ("Read all files.")

        self.createData()

        print ("Created Data.")

        logger.info("Update info for Source IPs : %s", self.sourceIP)
        logger.info("Update info for Target IPs : %s", self.targetIP)
        logger.info("Update info for Classifications : %s", self.classification)
        
        if cleanDBFromAlert:
            logger.info("Clean database and reset RIDs for class alert and alertcontext.")
            self.cleanDB()

        print ("Cleaned Database")

        for fileName in self.alertList.keys():
            self.createAlerts(fileName)

        print ("Inserted Alerts.")

        print (self.timeList)

        

